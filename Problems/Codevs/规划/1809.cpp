/*
河床
分析：此题很好，值得深入研究 
	这里先引用秦岳的方法：
	由于连续的一段必然有d(i)最大的点，故
	第①步问题转化：将原题改为为"求强制以i为区间结尾，且di是最大值的满足条件的最长区间长度"
	设f(i)表示选择区间以i为结尾且i为最大值时的最长区间长度。如果能顺利求出f(i)，那么答案就是max{f(i)+f'(i)-1} (f'(i)是将数组反转后一模一样的流程重新求一遍f(i)后，原来i对应的新的f(i)，整个式子的意义是以i为最高点向左/向右延伸最长长度之和)
	(补充:f(i)最简单的O(n^2)计算方法就是for(j=i;j>0&&h[j]<=h[i]&&h[i]-h[j]<=k;j--)f[i]++;)
	利用单调性优化可将求f(i)的过程优化至O(n)：
	设l1为i左侧最靠近i的点满足d(l1)>d(i)，l2为i左侧最靠近i的点满足d(l2)<d(i)-k，(意义为只要选择的区间包括l1/l2，那么就不满足上界/下界约束)
	第②步问题转化：只要能求出每个i对应的l1,l2，那么f(i)=i-max(l1,l2);
	此时单调栈优化就显而易见了，以求l1为例：
	若dj比j~i之间的某一个点(假设为k)d值小，那么点j永远不可能成为l1，故可以维护一个单调栈记录d1~di中可能成为l1的点q(1),q(2),......,q(t)（q(t)为栈顶,栈q中元素值单调增），易知当a<b时，恒有d(q(a))>d(q(b))。指针i从1到n扫描一遍，边维护单调栈边查询相应i对应的l1。具体方法为：①若d(q(t))>d(i)则l1=q(t)（若q为空则l1不存在），i入栈
	②若d(q(t))<=d(i)则出现比q(t)值大的点，q(t)永远不可能成为后面i的l1，故q(t)出栈，重复操作②直到操作①满足或栈为空
	时间复杂度的证明：单调栈插入或弹出均为O(1)，每个元素最多入栈出栈各一次，单次操作均摊O(1)，故求l1总复杂度为O(n)，类似方法可求得l2，之后求出f(i)复杂度O(n)，求出answer复杂度O(n)
	4,3,2,3,2当i=3时栈元素应该是{1,2,3}(从栈底到栈顶记录的下标)，然后i=4时发现3>=2,弹栈;接着发现3>=3继续弹栈;然后3>=4不成立了，此时栈里是{1}，i=4对应的l1就是栈顶元素1，之后将i=4入栈，栈里变为{1,4}至此i=4维护结束
	关于求l2的详细解释：求l2需要单调队列，维护一个随i变化d值单调增的下标队列，处理i时，将队列头部d值>=d(i)的元素全部出队，然后i入队，然后队尾元素d值<d(i)-k的部分出队至只剩一个元素d值<d(i)-k，l2就是此时的队尾元素下标。正确性可以先自己想想为什么(提示：需要利用求l1时的栈单调性)
	对于上面求l2的方法求得的l2不一定对于所有i准确，但可以保证对于真实的l2>l1时求得的l2是准确的，当l1>真实l2时不需要求l2(因为是l1进行转移)，求l2只是为了维护l2的单调队列 
	故运用单调性优化时间复杂度为O(n) 
	
	首先N^2的算法AC了9个点
	然后单调队列没懂。。。 
	
	还有DP方法：没太搞懂。。。 
	设 dp[n][k]为在第n个测量点，在满足接下来水位能下降k的前提下，之前连续的的一段最多有多长。
	令 t= depth[i-1]-depth[i]+j；
	则 dp[i][j]=1            |if t<0 或者 t>k
	            dp[i-1][t]+1 |if t>=0 且 t<=k 
*/
#include<iostream>
#include<algorithm>
using namespace std;
const int MAXN=30000;
int n,h[MAXN+3],f1[MAXN+3],f2[MAXN+3],k;
void input(){
	cin>>n>>k;
	for(int i=1;i<=n;i++)cin>>h[i];
}
int solve(){
	for(int i=1;i<=n;i++){
		for(int j=i;j>0&&h[j]<=h[i]&&h[i]-h[j]<=k;j--)f1[i]++;
	}
	for(int i=n;i>=1;i--){
		for(int j=i;j<=n&&h[j]<=h[i]&&h[i]-h[j]<=k;j++)f2[i]++;
	}
	int ans=0;
	for(int i=1;i<=n;i++){
		ans=max(ans,f1[i]+f2[i]-1);
	}
	return ans;
} 
int opt[MAXN+3][100+3];
int dp(){
	int ans=0;
	//初始化是否有必要？ 
	//for(int i=1;i<=k;i++)opt[0][i]=1;
	for(int i=1;i<=n;i++){
		for(int j=0;j<=k;j++){
			int t=h[i-1]-h[i]+j;
			if(t>=0&&t<=k)opt[i][j]=opt[i-1][t]+1;
			else opt[i][j]=1;
			ans=max(ans,opt[i][j]);
		}
	} 
	return ans;
} 
int main(){
	input();
	cout<<dp(); 
	return 0;
}

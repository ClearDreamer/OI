/*
田忌赛马
分析：这个问题很显然可以转化成一个二分图最佳匹配的问题。把田忌的马放左边，把齐王的马放右边。田忌的马A和齐王的B之间，如果田忌的马胜，则连一条权为200的边；如果平局，则连一条权为0的边；如果输，则连一条权为－200的边。
	  然而我们知道，二分图的最佳匹配算法的复杂度很高，无法满足N＝2000的要求。
	  我们不妨用贪心思想来分析一下问题。因为田忌掌握有比赛的“主动权”，他总是根据齐王所出的马来分配自己的马，所以这里不妨认为齐王的出马顺序是按马的速度从高到低出的。由这样的假设，我们归纳出如下贪心策略：
		1、如果田忌剩下的马中最强的马都赢不了齐王剩下的最强的马，那么应该用最差的一匹马去输给齐王最强的马。
	  	2、如果田忌剩下的马中最强的马可以赢齐王剩下的最强的马，那就用这匹马去赢齐王剩下的最强的马。 
		3、如果田忌剩下的马中最强的马和齐王剩下的最强的马打平的话，可以选择打平或者用最差的马输掉比赛。
	  第一个贪心策略的证明：此时田忌的所有马都赢不了齐王的马，所以无论用最慢马去输还是用最快的马去输都同样是输，而处于贪心的思想，我们应该保留相比之下更强的马，因此用最慢的马去输一定不会比用别的马去输来得劣，所以这是最优策略。
	  第二个贪心策略的证明：
	  	假设现在齐王剩下的最强的马是A，田忌剩下的最强的马是B，如果存在一种更优的比赛策略，让B的对手不是A，而使得田忌赢更多的钱的话，那么设此时A的对手是b，B的对手是a：
		若b>A，则有B>a，b>A。这个结果和B>A，b>a是相同的。
		若a<b≤A，则有B>a，b≤A。这个结果不如B>A，b>a来得优秀。
		若b≤a≤A，则有B>a，b≤A。这个结果和B>A，b≤a是相同的。
		由此可知，交换各自对手后，一定不会使得结果变劣，那么假设是不成立的。
	  第三个贪心策略的证明：
		因为田忌最快的马也只是和齐王的马打平，那么田忌只能选择平或输，选择平的话，当然只能用最快的马去平了；选择输的话当时是用最慢的马去输来得值得，这和第一个贪心策略的思路是一样的。
	  我们发现，第三个贪心策略出现了一个分支：打平或输掉。如果穷举所有的情况，算法的复杂度将比求二分图最佳匹配还要高；如果一概而论的选择让最强的马去打平比赛或者是让最差的马去输掉比赛，则存在反例：
		光是打平的话，如果齐王马的速度分别是1 2 3，田忌马的速度也是1 2 3，每次选择打平的话，田忌一分钱也得不到，而如果选择先用速度为1的马输给速度为3的马的话，可以赢得200两黄金。
		光是输掉的话，如果齐王马的速度分别是1 3，田忌马的速度分别是2 3，田忌一胜一负，仍然一分钱也拿不到。而如果先用速度为3的马去打平的话，可以赢得200两黄金。
	  虽然因为第三个贪心出现了分支，我们不能直接的按照这种方法来设计出一个完全贪心的方法，但是通过上述的三种贪心策略，我们可以发现，如果齐王的马是按速度排序之后，从高到低被派出的话，田忌一定是将他马按速度排序之后，从两头取马去和齐王的马比赛。有了这个信息之后，动态规划的模型也就出来了！
		设f[i,j]表示齐王按从强到弱的顺序出马和田忌进行了i场比赛之后，从“头”取了j匹较强的马，从“尾”取了i-j匹较弱的马，所能够得到的最大盈利。
		状态转移方程如下：
		f[i,j]=max{f[i-1,j]+g[n-(i-j)+1,i],f[i-1,j-1]+g[j,i]}
		其中g[i,j]表示田忌的马和齐王的马分别按照由强到弱的顺序排序之后，田忌的第i匹马和齐王的第j匹马赛跑所能取得的盈利，胜为200，输为－200，平为0。 

	  方法2：俩数组 ，排序，l1=1; l2=1; r1=n; r2=n;
	  	（ 左向右  如果  a[l1]>b[l2] 则  l1:=l1+1; l2:=l2+1; ans:=ans+200;
		 右往左 如果   a[r1]>b[r2] 则  r1:=r1-1;   r2:=r2-1; ans:=ans+200;
		 此时如果 a[l1]=b[r2] 则中间的数全相等，不用算了。。
	     如果 a[l1]<b[r2] 则  s:=s-200;  l1:=l1+1; r2:=r2-1;）
		继续（） 的循环； 
		
	  方法3：先从小到大排序 ，然后dp，令f[i][j]表示田忌i匹，应对齐王j匹的最优化赢次数
	  	 则有f[i][j]=max{f[i][j-1],f[i-1][j])-1 选择输掉这一场（用之前的马来应对b[j]这匹马） 
		                 f[i-1][j-1]+1 			可以赢得（a[i]>b[j]），用a[i]去比
						 f[i-1][j-1]			可以打平（a[i]==b[j]），用a[i]去比 
*/
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cstdio>
using namespace std;
const int MAXN=1000,INF=0x3f3f3f3f;
int n,a[MAXN+3],b[MAXN+3],opt[MAXN+3][MAXN+3];
int dp(){
	memset(opt,0,sizeof(opt));
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			opt[i][j]=max(opt[i][j-1],opt[i-1][j])-1;
			if(a[i]>b[j])opt[i][j]=max(opt[i][j],opt[i-1][j-1]+1);
			else if(a[i]==b[j])opt[i][j]=max(opt[i][j],opt[i-1][j-1]);
		}
	}
	return opt[n][n];
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=1;i<=n;i++)cin>>b[i];
	sort(a+1,a+n+1);
	sort(b+1,b+n+1);
	cout<<dp()*200;
	return 0;
}

